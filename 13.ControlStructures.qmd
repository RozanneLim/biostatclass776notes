---
title: "Lecture 13: Control Structures"
format: html
author: "Rozanne Lim"
---

# Commonly used control structures
- if and else: testing a condition and acting on it
- for: execute a loop a fixed number of times
- while: execute a loop while a condition is true
- repeat: execute an infinite loop (must break out of it to stop)
- break: break the execution of a loop
- next: skip an interation of a loop

# If Else 
```{r}
#| eval = FALSE

if (<condition1>) {
    ## do something
} else if (<condition2>)  {
    ## do something different
} else {
    ## do something entirely different
}
```

*Another way of writing*
```{r}
y <- if (x > 3) {
    10
} else {
    0
}

y
```

**Practice Question**
Let’s use the palmerpenguins dataset and write a if-else statement that
1. Randomly samples a value from a standard normal distribution (Hint: check out the rnorm(n, mean = 0, sd = 1) function in base R).
2. If the value is larger than 0, use dplyr functions to keep only the Chinstrap penguins.
3. Otherwise, keep only the Gentoo penguins.
4. Re-run the code 10 times and look at the output.

```{r}
library(palmerpenguins)
library(tidyverse)
penguins <- penguins

x <- rnorm(1, mean = 0, sd = 1)
if (x > 0){
    penguins %>%
        filter(species == "Chinstrap") 
} else {
    penguins %>%
        filter(species == "Gentoo")
}
```

# For Loops 
In R, for loops take an iterator variable and assign it successive values from a sequence or vector.
For loops are most commonly used for iterating over the elements of an object (list, vector, etc.)

This loop takes the i variable and in each iteration of the loop gives it values 1, 2, 3, …, 10, then executes the code within the curly braces, and then the loop exits.

```{r}
for (i in 1:10) {
    print(i)
}
```

*printing just i*
```{r}
## define the loop to iterate over
x <- c("a", "b", "c", "d")

## create for loop
for (i in 1:4) {
    ## Print out just 'i'
    print(i)
}
```

**Seq_along()**

The seq_along() function is commonly used in conjunction with for loops in order to generate an integer sequence based on the length of an object (or ncol() of an R object) (in this case, the object x).

```{r}
## Generate a sequence based on length of 'x'

x <- c("a", "b", "c", "d") 

for (i in seq_along(x)) {
    print(x[i])
}
```

For one line loops, curly braces are not necessary. 
Example: 
```{r}
for (i in 1:4) print(x[i])
```

**Practice Question**
Let’s use the palmerpenguins dataset. Here are the tasks:
1. Start a for loop
2. Iterate over the columns of penguins
3. For each column, extract the values of that column (Hint: check out the pull() function in dplyr).
4. Using a if-else statement, test whether or not the values in the column are numeric or not (Hint: remember the is.numeric() function to test if a value is numeric).
5. If they are numeric, compute the column mean. Otherwise, report a NA.

```{r}
library(dplyr)
for (i in seq_along(penguins)){
    col_name <- names(penguins)[i]
    col_values <- pull(penguins, col_name)
    
    if (is.numeric(col_values)) {
        col_mean <- mean(col_values, na.rm = TRUE)
        print(col_mean)
    } else {
        print(paste("Column", col_name, "is not numeric. Returning NA."))
    }
}
```

**Nested for loops**
For loops can be nested inside of each other.
Nested loops are commonly needed for multidimensional or hierarchical data structures (e.g. matrices, lists). Be careful with nesting though.
Nesting beyond 2 to 3 levels often makes it difficult to read/understand the code.

Example: 
```{r}
x <- matrix(1:6, nrow = 2, ncol = 3)
x
```

```{r}
for (i in seq_len(nrow(x))) {
    for (j in seq_len(ncol(x))) {
        print(x[i, j])
    }
}
```

# While Loops
while loops begin by testing a condition.

If it is true, then they execute the loop body.

Once the loop body is executed, the condition is tested again, and so forth, until the condition is false, after which the loop exits.

Example 1: 
```{r}
count <- 0
while (count < 10) {
    print(count)
    count <- count + 1
}
```

Example 2: 
```{r}
z <- 5
set.seed(1)

while (z >= 3 && z <= 10) {
    coin <- rbinom(1, 1, 0.5)

    if (coin == 1) { ## random walk
        z <- z + 1
    } else {
        z <- z - 1
    }
}
print(z)
```

# Repeat Loops
Repeat initiates an infinite loop right from the start. These are not commonly used in statistical or data analysis applications, but they do have their uses.
The only way to exit a repeat loop is to call break.

Example: 

```{r}
x0 <- 1
tol <- 1e-8

repeat {
    x1 <- computeEstimate() #fake function 

    if (abs(x1 - x0) < tol) { ## Close enough?
        break
    } else {
        x0 <- x1
    }
}
```

The loop above is a bit dangerous because there is no guarantee it will stop.
You could get in a situation where the values of x0 and x1 oscillate back and forth and never converge.
Better to set a hard limit on the number of iterations by using a for loop and then report whether convergence was achieved or not.

# Next, break
next is used to skip an iteration of a loop.

```{r}
for (i in 1:100) {
    if (i <= 20) {
        ## Skip the first 20 iterations
        next
    }
    ## Do something here on iteration 21 and beyond
}
```

break is used to exit a loop immediately, regardless of what iteration the loop may be on.

```{r}
for (i in 1:100) {
    print(i)

    if (i > 20) {
        ## Stop loop after 20 iterations
        break
    }
}
```